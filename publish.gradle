import cash.z.ecc.android.Deps

/////////////////////////////////////////
// Publishing
/////////////////////////////////////////

group = Deps.group
version = Deps.versionName

// Create the pom configuration:
def pomConfig = {
    licenses {
        license {
            name "MIT-style"
            url "http://opensource.org/licenses/MIT"
            distribution "repo"
        }
    }
    developers {
        developer {
            id "gmale"
            name "Kevin Gorham"
            email "kevin.gorham@z.cash"
        }
    }

    scm {
        url Deps.githubUrl
    }
}

// Jar containing Kotlin sources
task sourcesJar(type: Jar) {
    archiveClassifier = 'sources'
    from kotlin.sourceSets.main.kotlin.srcDirs
}

// Jar containing docs
//task docsJar(type: Jar) {
//    archiveClassifier = "javadoc"
//    group = JavaBasePlugin.DOCUMENTATION_GROUP
//    dependsOn dokka
//    from dokka
//}

def activePublication = Deps.publishingTarget
publishing {
    publications {
        android.libraryVariants.all { variant ->
            if (variant.name != activePublication.variant) return

            Production(MavenPublication) {
                artifact variant.outputs[0].packageLibrary // the AAR
                artifact sourcesJar
 //               artifact docsJar
                groupId Deps.group
                artifactId activePublication.artifactId
                version Deps.versionName

                pom.withXml {
                    def root = asNode()
                    root.appendNode('description', Deps.description)
                    root.appendNode('name', activePublication.artifactId)
                    root.appendNode('url', )
                    root.children().last() + pomConfig

                    // AAR-specific: we must explicitly add dependencies for an AAR
                    def depsNode = root["dependencies"][0] ?: root.appendNode("dependencies")
                    def addDep = {
                        if (it.group == null) return // Avoid empty dependency nodes
                        def dependencyNode = depsNode.appendNode('dependency')
                        dependencyNode.appendNode('groupId', it.group)
                        dependencyNode.appendNode('artifactId', it.name)
                        dependencyNode.appendNode('version', it.version)
                        if (it.hasProperty('type')) {
                            dependencyNode.appendNode('type', it.type)
                        }
                        if (it.hasProperty('scope')) {
                            dependencyNode.appendNode('scope', it.scope)
                        }
                        if (it.hasProperty('optional') && it.optional) {
                            dependencyNode.appendNode('optional', 'true')
                        }
                    }
                    // run the 'addDep' closure over each dependency
                    configurations.implementation.allDependencies.each addDep
                }
            }
        }
    }
}

//bintray {
//    user = project.findProperty('bintrayUser') ?: System.getenv('BINTRAY_USER')
//    key = project.findProperty('bintrayApiKey') ?: System.getenv('BINTRAY_API_KEY')
//    publications = ['Production']
//    override = true
//    pkg {
//        repo = 'android'
//        name = activePublication.artifactId
//        description = Deps.description
//        publish = true
//        publicDownloadNumbers = true
//        userOrg = 'ecc-mobile'
//        labels = ['aar', 'native', 'android', 'zcash', 'ecc', 'sdk', 'kotlin', 'mobile', 'electric coin company', 'open source', 'crypto', 'cryptocurrency', 'cryptography', 'privacy']
//        licenses = ['MIT']
//        vcsUrl = Deps.githubUrl
//        dryRun = Deps.publishingDryRun
//        version {
//            name = Deps.versionName
//            desc = Deps.description
//            released = new Date()
//            vcsTag = this.version
//        }
//    }
//}
